import {
  BadRequestException,
  ConflictException,
  ForbiddenException,
  Inject,
  Injectable,
  InternalServerErrorException,
  Logger,
  LoggerService,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common'
import { SignUpDto } from './dtos/sign-up.dto'
import { SignInDto } from './dtos/sign-in.dto'
import { jwtConfigs } from '../configs/jwt.configs'
import { ConfigType } from '@nestjs/config'

import { UsersService } from 'src/iam/users/users.service'
import { JwtService } from '@nestjs/jwt'
import { TUserDoc } from 'src/iam/users/schema/user.schema'
import { AccessesService } from 'src/iam/authorization/accesses/accesses.service'
import { RolesService } from 'src/iam/authorization/roles/roles.service'
import { EPremiumSubscribers } from 'src/iam/enums/e-roles.enum'
import { FactoryUtils } from 'src/common/services/factory.utils'
import { HashingService } from '../bcrypt/hashing.service'

@Injectable()
export class AuthService {
  private readonly logger: LoggerService = new Logger(AuthService.name)

  private readonly defaultRole: EPremiumSubscribers =
    EPremiumSubscribers.GUEST_USER

  constructor(
    @Inject(jwtConfigs.KEY)
    private readonly jwtConfig: ConfigType<typeof jwtConfigs>,

    private readonly userService: UsersService,

    private readonly accessesService: AccessesService,

    private readonly rolesService: RolesService,

    private readonly jwtService: JwtService,

    private readonly hashingService: HashingService,

    private readonly factoryUtils: FactoryUtils,
  ) {}

  async signUp(signUpDto: SignUpDto) {
    let newUser: TUserDoc

    try {
      // 1). creating a new user
      newUser = await this.userService.create(signUpDto)

      // 2). sign a token - pass
      const accessToken = await this.signToken(newUser)

      // 3). set default role of user to be a guest
      await this.assignDefaultRole(newUser)

      // 4). @TODO: Send an email to user

      return {
        accessToken,
        data: newUser,
      }
    } catch (error) {
      // rollback registering the user
      if (newUser) {
        await this.userService.removeHelper(newUser.id)
      }

      // logger
      this.logger.warn(error.message)
      this.logger.error(error)

      const message = `Creating your account failed, please try again later`

      // validation messages
      if (error instanceof NotFoundException) {
        new NotFoundException(message)
      }

      if (error instanceof ForbiddenException) {
        new ForbiddenException(message)
      }

      if (error.code === 11000) {
        const message = this.factoryUtils.autoGenerateDuplicateMessage(error)
        throw new ConflictException(message || message)
      }

      if (error instanceof Error && error.name === 'ValidationError') {
        throw new BadRequestException(message)
      }

      throw new InternalServerErrorException(message)
    }
  }

  async signIn(signInDto: SignInDto) {
    const message = 'Password or email does not match'
    const { email, password } = signInDto
    try {
      // 1). Verify user
      const foundUser = await this.userService.findOneHelper('custom', {
        email,
      })

      // 2). Verify password
      const passwordMatches = await this.hashingService.compare(
        password,
        foundUser.password,
      )

      if (!passwordMatches) {
        throw new ForbiddenException()
      }

      // 3). sign a token - pass
      const accessToken = await this.signToken(foundUser)

      // 4). set default role of user to be a guest
      await this.assignDefaultRole(foundUser)

      // 5). @TODO: Send an email to user

      return {
        accessToken,
        data: foundUser,
      }
    } catch (error) {
      this.logger.warn(
        `User with email ${email} could not signin because of invalid credentials`,
      )

      this.logger.error(error)

      throw new UnauthorizedException(message)
    }
  }

  /**
   * ------------------------------
   *
   *         HELPERS
   *
   * -----------------------------
   */
  private async signToken(newUser: TUserDoc) {
    const payload = {
      id: newUser.id,
    }

    return this.jwtService.signAsync(payload, {
      secret: this.jwtConfig.secret,
      audience: this.jwtConfig.audience,
      issuer: this.jwtConfig.issuer,
      expiresIn: this.jwtConfig.accessTokenTTL,
    })
  }

  private async assignDefaultRole(newUser: TUserDoc) {
    const role = await this.rolesService.findOneHelper(this.defaultRole)

    const { id } = role

    const accessDto = {
      assignedTo: newUser.id,
      roleId: id,
      accountOwner: newUser.id,
      baseRole: this.defaultRole,
    }

    this.accessesService.createAccessHelper(accessDto)
  }
}
