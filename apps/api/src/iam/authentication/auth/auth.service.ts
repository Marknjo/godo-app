import {
  BadRequestException,
  ConflictException,
  ForbiddenException,
  Inject,
  Injectable,
  InternalServerErrorException,
  Logger,
  LoggerService,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common'
import { SignUpDto } from './dtos/sign-up.dto'
import { SignInDto } from './dtos/sign-in.dto'
import { jwtConfigs } from '../configs/jwt.configs'
import { ConfigType } from '@nestjs/config'

import { UsersService } from 'src/iam/users/users.service'
import { JwtService } from '@nestjs/jwt'
import { TUserDoc } from 'src/iam/users/schema/user.schema'
import { AccessesService } from 'src/iam/authorization/accesses/accesses.service'
import { RolesService } from 'src/iam/authorization/roles/roles.service'
import { EPremiumSubscribers } from 'src/iam/enums/e-roles.enum'
import { FactoryUtils } from 'src/common/services/factory.utils'
import { HashingService } from '../bcrypt/hashing.service'
import { IActiveUser } from 'src/iam/interfaces/i-active-user'

@Injectable()
export class AuthService {
  private readonly logger: LoggerService = new Logger(AuthService.name)

  private readonly defaultRole: EPremiumSubscribers =
    EPremiumSubscribers.GUEST_USER

  constructor(
    @Inject(jwtConfigs.KEY)
    private readonly jwtConfig: ConfigType<typeof jwtConfigs>,

    private readonly userService: UsersService,

    private readonly accessesService: AccessesService,

    private readonly rolesService: RolesService,

    private readonly jwtService: JwtService,

    private readonly hashingService: HashingService,

    private readonly factoryUtils: FactoryUtils,
  ) {}

  async signUp(signUpDto: SignUpDto) {
    let newUser: TUserDoc

    try {
      // 1). creating a new user
      newUser = await this.userService.create(signUpDto)

      // 2). sign a token - pass
      const accessToken = await this.signToken(newUser.id)

      // 3). set default role of user to be a guest
      await this.assignDefaultRole(newUser)

      // 4). @TODO: Send an email to user

      return {
        accessToken,
        data: newUser,
      }
    } catch (error) {
      // rollback registering the user
      if (newUser) {
        await this.userService.removeHelper(newUser.id)
      }

      // logger
      this.logger.warn(error.message)
      this.logger.error(error)

      const message = `Creating your account failed, please try again later`

      // validation messages
      if (error instanceof NotFoundException) {
        new NotFoundException(message)
      }

      if (error instanceof ForbiddenException) {
        new ForbiddenException(message)
      }

      if (error.code === 11000 || error instanceof ConflictException) {
        const autoMessage =
          this.factoryUtils.autoGenerateDuplicateMessage(error)

        throw new ConflictException(autoMessage || message)
      }

      if (error instanceof Error && error.name === 'ValidationError') {
        throw new BadRequestException(message)
      }

      throw new InternalServerErrorException(message)
    }
  }

  async signIn(signInDto: SignInDto) {
    const message = 'Password or email does not match'
    const { email, password } = signInDto
    try {
      // 1). Verify user
      const foundUser = await this.userService.findOneHelper('custom', {
        email,
      })

      // 2). Verify password
      const passwordMatches = await this.hashingService.compare(
        password,
        foundUser.password,
      )

      if (!passwordMatches) {
        throw new ForbiddenException()
      }

      // 3). sign a token - pass
      const accessToken = await this.signToken(foundUser.id)

      return {
        accessToken,
        data: foundUser,
      }
    } catch (error) {
      this.logger.warn(
        `User with email ${email} could not signin because of invalid credentials`,
      )

      this.logger.error(error)

      throw new UnauthorizedException(message)
    }
  }

  async switchAccount(accountOwnerId: string, activeUser: IActiveUser) {
    const memberId = activeUser?.memberId

    this.logger.log(`User id ${memberId} is switching account`)

    try {
      if (memberId) {
        throw new ForbiddenException(
          `Please switch to an account you are a member of`,
        )
      }

      // 1) find the access from access service
      const foundAccess = await this.accessesService.findOneHelper(true, {
        assignedTo: memberId,
        accountOwner: accountOwnerId,
        $and: [{ isEnabled: true }],
      })

      // 2) if there is an access, generate a new token, client direct into another
      // 3) assign token a payload with two items, id accountOwnerId, memberId
      const accessToken = await this.signToken(accountOwnerId, memberId)

      return {
        accessToken,
        data: foundAccess,
      }
    } catch (error) {
      this.logger.warn(
        `User with id ${memberId} was not able to switch into an account of user with id ${accountOwnerId}`,
      )
      this.logger.error(error)

      if (
        error instanceof NotFoundException ||
        error instanceof ForbiddenException
      ) {
        throw new UnauthorizedException(
          `You lack enough credentials to switch into this account`,
        )
      }

      throw new InternalServerErrorException(
        `Failed to switch you to this account, please try again later`,
      )
    }
  }

  /**
   * ------------------------------
   *
   *         HELPERS
   *
   * -----------------------------
   */
  private async signToken<P extends Record<string, unknown>>(
    userId: string,
    memberId?: string,
    customPayload?: P,
  ) {
    const payload = {
      sub: userId,
      ...(memberId ? { memberId } : {}),
      ...(customPayload ? customPayload : {}),
    }

    return this.jwtService.signAsync(payload, {
      secret: this.jwtConfig.secret,
      audience: this.jwtConfig.audience,
      issuer: this.jwtConfig.issuer,
      expiresIn: this.jwtConfig.accessTokenTTL,
    })
  }

  private async assignDefaultRole(newUser: TUserDoc) {
    const role = await this.rolesService.findOneHelper(this.defaultRole)

    const { id } = role

    const accessDto = {
      assignedTo: newUser.id,
      roleId: id,
      accountOwner: newUser.id,
      baseRole: this.defaultRole,
    }

    this.accessesService.createAccessHelper(accessDto)
  }
}
